type Block {
  """
  The hash of the block
  """
  hash: ID! @unique

  """
  The block number
  """
  number: Long! @unique

  tokens: [Token!] @relation
}

type Token {
  id: String! @unique

  tokenID: String!
  mintTime: String!
  """
  Present when ERC721Metadata interface is implemented.
  """
  tokenAsset: TokenAsset

  contract: TokenContract! @relation
  owner: Owner! @relation
  blocks: [Block!] @relation

  imported: [ERC721ImportResult!] @relation
}

"""
TokenAsset represents contents of the tokenURI which may not have been found /
pinned yet. It may have been added by the chain scraper, when token with this
`tokenURI` was discovered. Alternatively it could have been created by an
upload to nft.storage, in which case it may not have any refferers but it would
have uploads.
"""
type TokenAsset {
  """
  Tokens that have this `tokenURI`. This relation allows us to identify all
  tokens that have a same `tokenURI`.
  """
  referrers: [Token!] @relation
  """
  Uploads to nft.storage that used `client.store(...)` method to add this.
  There maybe multipe of them as multiple users may have added exact same
  payload. It also may be empty if this was created from niftysave.
  """
  uploads: [Upload!] @relation

  tokenURI: String! @unique

  """
  When `tokenURI` points to may point to JSON file that conforms to the ERC721
  Metadata JSON Schema it fetched parsed and stored as related Metadata
  document.
  """
  metadata: Metadata @relation

  """
  CID of an IPLD node that encapsulates token metadata and all it's assets.
  Present when it was passibly to succesfully pin the token.
  """
  ipnft: String

  """
  Problem description if failed to get the metadata.
  """
  problem: String
}

type Metadata {
  source: TokenAsset! @relation @unique
  cid: String!

  """
  Identifies the asset this token represents
  """
  name: String!
  """
  Describes the asset this token represents
  """
  description: String!
  """
  A file representing the asset this token represents
  """
  image: Resource!

  """
  Additional assets that token linked to
  """
  assets: [Resource!] @relation
}

enum ResourceStatus {
  """
  Has not been processed yet
  """
  Idle
  """
  Pin request started. This usually implies that we found a CID in the
  tokenURI (because it was a gateway URL) so we started a pin but do not
  know if it was possible to fetch content.
  """
  PinQueued
  """
  Was pinned succesfully
  """
  Pinned

  # All kinds of error states

  """
  tokenURI is either malformed or the protocol is not supported.
  """
  FailedURIParse
  """
  Was unable to fetch the content.
  """
  FailedFetch
  """
  Pin request failed, can happen when pinned by CID but correspoding content
  is not on the network.
  """
  PinFailure
}

type Resource {
  referrers: [Metadata!] @relation
  uploads: [Upload!] @relation
  status: ResourceStatus! @index

  """
  URI with which resource was identified.
  """
  uri: String! @unique @index

  """
  ipfs:// url if `uri` was referring to gateway URL.
  """
  ipfsURL: String @index

  """
  CID that corresponds to this resource, set once resourec is pinned.
  """
  cid: String @index

  """
  Problem description if there was problem in pinning a resource.
  """
  problem: String
}

type Owner {
  id: ID! @unique
}

type TokenContract {
  id: ID! @unique
  """
  A descriptive name for a collection of NFTs in this contract
  """
  name: String
  """
  An abbreviated name for NFTs in this contract
  """
  symbol: String

  supportsEIP721Metadata: Boolean!

  tokens: [Token!] @relation
}

input ERC721MetadataQuery {
  name: String
  symbol: String
  tokenURI: String
  ipnft: String
}

input MetadaQuery {
  name: String
  description: String
  image: ResourceQuery
}

input ResourceQuery {
  uri: String
  cid: String
}

type Cursor {
  id: String!
}

type ERC721ImportResult {
  """
  Cursor from which import started.
  """
  id: String!
  """
  New cursor after this import.
  """
  nextID: String!
  """
  Tokens that were imported.
  """
  tokens: [Token!]! @relation
}

input ERC721ImportInput {
  """
  Cursor from which import started. If current cursor changed import will be
  rejected.
  """
  id: String!
  """
  Tokens to be imported.
  """
  tokens: [ERC721ImportTokenInput!]!
}

input ERC721ImportTokenInput {
  id: ID!
  tokenID: String!
  tokenURI: String!
  mintTime: String!

  blockHash: String!
  blockNumber: String!

  contract: ERC721ImportTokenContractInput!
  owner: ERC721ImportTokenOwnerInput!
}

input ERC721ImportTokenContractInput {
  id: ID!
  name: String
  symbol: String
  supportsEIP721Metadata: Boolean!
}

input ERC721ImportTokenOwnerInput {
  id: ID!
}

enum TokenAssetStatus {
  Queued
  Failed
  Succeeded
}

input FindTokenAssetsInput {
  status: TokenAssetStatus
}

input FindResourceInput {
  status: ResourceStatus
}

type Query {
  cursor: Cursor! @resolver
  tokens(tokenID: String, mintTime: String): [Token]!
  allTokens: [Token!]
  owner(id: ID): Owner
  block(hash: ID, number: Long): Block
  constract(id: ID): TokenContract

  allImports: [ERC721ImportResult!] @relation
  """
  Provides tokens with the
  """
  findTokenAssets(where: FindTokenAssetsInput): [TokenAsset!]!
    @resolver(paginated: true)
    @relation

  findResources(where: FindResourceInput): [Resource!]!
    @resolver(paginated: true)
    @relation
}

input TokenAssetProblemInput {
  """
  ID of the TokenAsset
  """
  tokenAssetID: ID!
  """
  Problem description
  """
  problem: String!
}

input TokenMetadataImportInput {
  tokenAssetID: ID!
  metadata: MetadataInput
}

input MetadataInput {
  """
  CID for the metadata content.
  """
  cid: String!

  """
  Identifies the asset this token represents
  """
  name: String!
  """
  Describes the asset this token represents
  """
  description: String!
  """
  A file representing the asset this token represents
  """
  image: ResourceInput!

  # """
  # Additional assets that token linked to
  # """
  assets: [ResourceInput!]!
}

input ResourceInput {
  uri: String!
  ipfsURL: String
}

input ResourceProblemInput {
  resourceID: ID!
  status: ResourceStatus!
  problem: String!
}

input ResorcePinInput {
  resourceID: ID!
  status: ResourceStatus!
  ipfsURL: String!
  cid: String!
}

type Mutation {
  importERC721(input: ERC721ImportInput!): ERC721ImportResult! @resolver

  """
  Reports problem with a TokenAsset e.g. it was impossible to parse URI
  or was unable to fetch content from URI, or content was not a JSON.

  Call is rejected if status isn't Queued.
  """
  reportTokenAssetProblem(input: TokenAssetProblemInput): TokenAsset! @resolver

  """
  Imports Token Metadata. Will be rejected if corresponding asset status isn't
  Queued. Otherwise updates corresponding TokenAsset transitioning it to
  Succeeded state.
  """
  importTokenMetadata(input: TokenMetadataImportInput): Metadata! @resolver

  reportResourceProblem(input: ResourceProblemInput): Resource! @resolver
  updateResourcePin(input: ResorcePinInput): Resource! @resolver

  importBlob(input: ImportBlobInput): Upload! @resolver
  importDirectory(input: ImportDirectoryInput): Upload! @resolver
  """
  API endpoint that corresponds to `/store` API of nft.storage.
  """
  importIPNFT(input: ImportIPNFTInput): Upload @resolver
}

# -------------- Schema from kv -------------------------

enum UploadMethod {
  Blob
  Car
  Directory
  IPNFT
}

# TODO: Need to split upload into per user uploads as following fiels
# may be different e.g. created, scope.
type Upload {
  cid: String!
  uploaders: [UserKey!] @relation

  """
  How it was uploaded to nft.storage as in which API endpoint.
  """
  method: UploadMethod!

  """
  ContentType of the upload, which will be form-data/multipart for multifile
  uploads, actual content type of the blob or an `application/car` for car
  imports.
  """
  contentType: String!

  """
  If method was 'IPNFT' then we have a `metadata` field otherwise it is going to
  be null and it will have an `assets` field instead.
  """
  tokenAsset: TokenAsset @relation

  """
  Resources that were part of the upload.
  """
  assets: [Resource!] @relation

  """
  Pinning service pin metadata.
  """
  pin: Pin @embedded

  created: Time!

  dagSize: Int!

  pinStatus: PinStatus!

  deals: [Deal!]!
}

type Deal {
  upload: Upload @relation @index

  lastChangedUnix: Time!
  pieceCID: String!
  status: DealStatus!
}

enum DealStatus {
  Proposing
  Accepted
  Failed
  Published
  Active
  Terminated
}

type Pin {
  name: String!
  """
  This JSON
  """
  meta: String!
}

enum PinStatus {
  UNDEFINED
  CLUSTER_ERROR
  PIN_ERROR
  UNPIN_ERROR
  PINNED
  PINNING
  UNPINNED
  REMOTE
  PIN_QUEUED
  UNPIN_QUEUED
  SHARDED
}

input UserInput {
  email: String!
}

input ImportDirectoryInput {
  cid: String!
  created: Time!
  auth: UserAuthInput!
  dagSize: Int!
  files: [ImportDirectoryFileInput!]!
}

input ImportDirectoryFileInput {
  name: String!
  contentType: String!
  cid: String!
}

input ImportBlobInput {
  cid: String!
  contentType: String!
  created: Time!
  auth: UserAuthInput!
  dagSize: Int!
}

input ImportCarInput {
  cid: String!
  created: Time!
  auth: UserAuthInput!
  dagSize: Int!
}

input ImportIPNFTInput {
  metadata: MetadataInput!
  """
  CID of the dag node encapsulating  NFT metadata and it's assets.
  """
  ipnft: String!
  """
  URI to the metadata.json. If omitted defaults to
  `ipfs://${ipnft}/metadata.json`
  """
  tokenURI: String

  """
  Token name.
  """
  #  Not sure about this one, we do have it in kv so we retain it here as well.
  # We should probably make it part of metadata instead though.
  scope: String!

  """
  Timestamp of when upload happened.
  """
  created: Time!

  # We have it in kv, I'm not sure why but we retain it here.
  dagSize: Int!

  """
  Used to find a corresponding user and associate an upload with it.
  """
  auth: UserAuthInput!

  # TODO:
  # 1. Do we need to include deals here ? I think no.
  # 2. Do we want to include pin here ? I don't think so.
}

"""
Represents users key.
"""
input UserAuthInput {
  secret: String!
}

# # From https://github.com/ipfs-shipyard/nft.storage/blob/c7e5130022ac1d0db13269582bdfa5e60d41bdea/packages/api/src/bindings.d.ts#L82-L92
type User {
  sub: String!
  nickname: String!
  name: String!
  email: String!
  picture: String!
  issuer: String!
  publicAddress: String!
  github: String

  """
  User authentification keys.
  """
  keys: [UserKey!]! @relation
}

type UserKey {
  """
  User this key belongs to.
  """
  user: User! @relation

  """
  User assigned title.
  """
  title: String!

  """
  Uploads made using this user key.
  """
  uploads: [Upload]! @relation

  """
  Secret that corresponds to this key.
  """
  secret: String! @index
}
